{"ast":null,"code":"// src/index.tsx\nimport { useEffect, useState } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar getScrollParent = node => {\n  let parent = node;\n  while (parent = parent.parentElement) {\n    const overflowYVal = getComputedStyle(parent, null).getPropertyValue(\"overflow-y\");\n    if (parent === document.body) return window;\n    if (overflowYVal === \"auto\" || overflowYVal === \"scroll\" || overflowYVal === \"overlay\") {\n      return parent;\n    }\n  }\n  return window;\n};\nvar isOffsetElement = el => el.firstChild ? el.firstChild.offsetParent === el : true;\nvar offsetTill = (node, target) => {\n  let current = node;\n  let offset = 0;\n  if (!isOffsetElement(target)) {\n    offset += node.offsetTop - target.offsetTop;\n    target = node.offsetParent;\n    offset += -node.offsetTop;\n  }\n  do {\n    offset += current.offsetTop;\n    current = current.offsetParent;\n  } while (current && current !== target);\n  return offset;\n};\nvar getParentNode = node => {\n  let currentParent = node.parentElement;\n  while (currentParent) {\n    const style = getComputedStyle(currentParent, null);\n    if (style.getPropertyValue(\"display\") !== \"contents\") break;\n    currentParent = currentParent.parentElement;\n  }\n  return currentParent || window;\n};\nvar stickyProp = null;\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n  if (CSS.supports(\"position\", \"sticky\")) stickyProp = \"sticky\";else if (CSS.supports(\"position\", \"-webkit-sticky\")) stickyProp = \"-webkit-sticky\";\n}\nvar passiveArg = false;\ntry {\n  const opts = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get() {\n      passiveArg = {\n        passive: true\n      };\n    }\n  });\n  const emptyHandler = () => {};\n  window.addEventListener(\"testPassive\", emptyHandler, opts);\n  window.removeEventListener(\"testPassive\", emptyHandler, opts);\n} catch (e) {}\nvar getDimensions = opts => {\n  const {\n    el,\n    onChange,\n    unsubs,\n    measure\n  } = opts;\n  if (el === window) {\n    const getRect = () => ({\n      top: 0,\n      left: 0,\n      height: window.innerHeight,\n      width: window.innerWidth\n    });\n    const mResult = measure(getRect());\n    const handler = () => {\n      Object.assign(mResult, measure(getRect()));\n      onChange();\n    };\n    window.addEventListener(\"resize\", handler, passiveArg);\n    unsubs.push(() => window.removeEventListener(\"resize\", handler));\n    return mResult;\n  } else {\n    const mResult = measure(el.getBoundingClientRect());\n    const handler = () => {\n      Object.assign(mResult, measure(el.getBoundingClientRect()));\n      onChange();\n    };\n    const ro = new ResizeObserver(handler);\n    ro.observe(el);\n    unsubs.push(() => ro.disconnect());\n    return mResult;\n  }\n};\nvar getVerticalPadding = node => {\n  const computedParentStyle = getComputedStyle(node, null);\n  const parentPaddingTop = parseInt(computedParentStyle.getPropertyValue(\"padding-top\"), 10);\n  const parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue(\"padding-bottom\"), 10);\n  return {\n    top: parentPaddingTop,\n    bottom: parentPaddingBottom\n  };\n};\nvar setup = (node, unsubs, opts) => {\n  const {\n    bottom,\n    offsetBottom,\n    offsetTop\n  } = opts;\n  const scrollPane = getScrollParent(node);\n  let isScheduled = false;\n  const scheduleOnLayout = () => {\n    if (!isScheduled) {\n      requestAnimationFrame(() => {\n        const nextMode = onLayout();\n        if (nextMode !== mode) {\n          changeMode(nextMode);\n        } else if (nextMode === 1 /* stickyBottom */ && !bottom) {\n          const {\n            height: viewPortHeight\n          } = scrollPaneDims;\n          const {\n            height: nodeHeight\n          } = nodeDims;\n          node.style.top = \"\".concat(viewPortHeight - nodeHeight - offsetBottom, \"px\");\n        } else if (nextMode === 2 /* relative */) {\n          const {\n            height: viewPortHeight,\n            offsetTop: scrollPaneOffset\n          } = scrollPaneDims;\n          const {\n            height: parentHeight,\n            naturalTop\n          } = parentDims;\n          const {\n            height: nodeHeight\n          } = nodeDims;\n          const relativeOffset2 = Math.max(0, scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom));\n          if (bottom) {\n            const nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset2);\n            node.style.bottom = \"\".concat(nextBottom, \"px\");\n          } else {\n            node.style.top = \"\".concat(relativeOffset2, \"px\");\n          }\n        }\n        isScheduled = false;\n      });\n    }\n    isScheduled = true;\n  };\n  let latestScrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;\n  const isBoxTooLow = scrollY => {\n    const {\n      offsetTop: scrollPaneOffset,\n      height: viewPortHeight\n    } = scrollPaneDims;\n    const {\n      naturalTop\n    } = parentDims;\n    const {\n      height: nodeHeight\n    } = nodeDims;\n    if (scrollY + scrollPaneOffset + viewPortHeight >= naturalTop + nodeHeight + relativeOffset + offsetBottom) {\n      return true;\n    }\n    return false;\n  };\n  const onLayout = () => {\n    const {\n      height: viewPortHeight\n    } = scrollPaneDims;\n    const {\n      height: nodeHeight\n    } = nodeDims;\n    if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {\n      return 3 /* small */;\n    } else {\n      if (isBoxTooLow(latestScrollY)) {\n        return 1 /* stickyBottom */;\n      } else {\n        return 2 /* relative */;\n      }\n    }\n  };\n  const scrollPaneIsOffsetEl = scrollPane !== window && isOffsetElement(scrollPane);\n  const scrollPaneDims = getDimensions({\n    el: scrollPane,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: _ref => {\n      let {\n        height,\n        top\n      } = _ref;\n      return {\n        height,\n        offsetTop: scrollPaneIsOffsetEl ? top : 0\n      };\n    }\n  });\n  const parentNode = getParentNode(node);\n  const parentPaddings = parentNode === window ? {\n    top: 0,\n    bottom: 0\n  } : getVerticalPadding(parentNode);\n  const parentDims = getDimensions({\n    el: parentNode,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: _ref2 => {\n      let {\n        height\n      } = _ref2;\n      return {\n        height: height - parentPaddings.top - parentPaddings.bottom,\n        naturalTop: parentNode === window ? 0 : offsetTill(parentNode, scrollPane) + parentPaddings.top + scrollPaneDims.offsetTop\n      };\n    }\n  });\n  const nodeDims = getDimensions({\n    el: node,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: _ref3 => {\n      let {\n        height\n      } = _ref3;\n      return {\n        height\n      };\n    }\n  });\n  let relativeOffset = 0;\n  let mode = onLayout();\n  const changeMode = newMode => {\n    const prevMode = mode;\n    mode = newMode;\n    if (prevMode === 2 /* relative */) relativeOffset = -1;\n    if (newMode === 3 /* small */) {\n      node.style.position = stickyProp;\n      if (bottom) {\n        node.style.bottom = \"\".concat(offsetBottom, \"px\");\n      } else {\n        node.style.top = \"\".concat(offsetTop, \"px\");\n      }\n      return;\n    }\n    const {\n      height: viewPortHeight,\n      offsetTop: scrollPaneOffset\n    } = scrollPaneDims;\n    const {\n      height: parentHeight,\n      naturalTop\n    } = parentDims;\n    const {\n      height: nodeHeight\n    } = nodeDims;\n    if (newMode === 2 /* relative */) {\n      node.style.position = \"relative\";\n      relativeOffset = prevMode === 0 /* stickyTop */ ? Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop) : Math.max(0, scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom));\n      if (bottom) {\n        const nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset);\n        node.style.bottom = \"\".concat(nextBottom, \"px\");\n      } else {\n        node.style.top = \"\".concat(relativeOffset, \"px\");\n      }\n    } else {\n      node.style.position = stickyProp;\n      if (newMode === 1 /* stickyBottom */) {\n        if (bottom) {\n          node.style.bottom = \"\".concat(offsetBottom, \"px\");\n        } else {\n          node.style.top = \"\".concat(viewPortHeight - nodeHeight - offsetBottom, \"px\");\n        }\n      } else {\n        if (bottom) {\n          node.style.bottom = \"\".concat(viewPortHeight - nodeHeight - offsetBottom, \"px\");\n        } else {\n          node.style.top = \"\".concat(offsetTop, \"px\");\n        }\n      }\n    }\n  };\n  changeMode(mode);\n  const onScroll = scrollY => {\n    if (scrollY === latestScrollY) return;\n    const scrollDelta = scrollY - latestScrollY;\n    latestScrollY = scrollY;\n    if (mode === 3 /* small */) return;\n    const {\n      offsetTop: scrollPaneOffset,\n      height: viewPortHeight\n    } = scrollPaneDims;\n    const {\n      naturalTop,\n      height: parentHeight\n    } = parentDims;\n    const {\n      height: nodeHeight\n    } = nodeDims;\n    if (scrollDelta > 0) {\n      if (mode === 0 /* stickyTop */) {\n        if (scrollY + scrollPaneOffset + offsetTop > naturalTop) {\n          const topOffset = Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop);\n          if (scrollY + scrollPaneOffset + viewPortHeight <= naturalTop + nodeHeight + topOffset + offsetBottom) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(1 /* stickyBottom */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (isBoxTooLow(scrollY)) changeMode(1 /* stickyBottom */);\n      }\n    } else {\n      if (mode === 1 /* stickyBottom */) {\n        if (scrollPaneOffset + scrollY + viewPortHeight < naturalTop + parentHeight + offsetBottom) {\n          const bottomOffset = Math.max(0, scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom));\n          if (scrollPaneOffset + scrollY + offsetTop >= naturalTop + bottomOffset) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(0 /* stickyTop */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (scrollPaneOffset + scrollY + offsetTop < naturalTop + relativeOffset) {\n          changeMode(0 /* stickyTop */);\n        }\n      }\n    }\n  };\n  const handleScroll = scrollPane === window ? () => onScroll(window.scrollY) : () => onScroll(scrollPane.scrollTop);\n  scrollPane.addEventListener(\"scroll\", handleScroll, passiveArg);\n  scrollPane.addEventListener(\"mousewheel\", handleScroll, passiveArg);\n  unsubs.push(() => scrollPane.removeEventListener(\"scroll\", handleScroll), () => scrollPane.removeEventListener(\"mousewheel\", handleScroll));\n};\nvar useStickyBox = function () {\n  let {\n    offsetTop = 0,\n    offsetBottom = 0,\n    bottom = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const [node, setNode] = useState(null);\n  useEffect(() => {\n    if (!node || !stickyProp) return;\n    const unsubs = [];\n    setup(node, unsubs, {\n      offsetBottom,\n      offsetTop,\n      bottom\n    });\n    return () => {\n      unsubs.forEach(fn => fn());\n    };\n  }, [node, offsetBottom, offsetTop, bottom]);\n  return setNode;\n};\nvar StickyBox = props => {\n  const {\n    offsetTop,\n    offsetBottom,\n    bottom,\n    children,\n    className,\n    style\n  } = props;\n  const ref = useStickyBox({\n    offsetTop,\n    offsetBottom,\n    bottom\n  });\n  return /* @__PURE__ */jsx(\"div\", {\n    className,\n    style,\n    ref,\n    children\n  });\n};\nvar src_default = StickyBox;\nexport { src_default as default, useStickyBox };","map":{"version":3,"names":["useEffect","useState","jsx","getScrollParent","node","parent","parentElement","overflowYVal","getComputedStyle","getPropertyValue","document","body","window","isOffsetElement","el","firstChild","offsetParent","offsetTill","target","current","offset","offsetTop","getParentNode","currentParent","style","stickyProp","CSS","supports","passiveArg","opts","Object","defineProperty","get","passive","emptyHandler","addEventListener","removeEventListener","e","getDimensions","onChange","unsubs","measure","getRect","top","left","height","innerHeight","width","innerWidth","mResult","handler","assign","push","getBoundingClientRect","ro","ResizeObserver","observe","disconnect","getVerticalPadding","computedParentStyle","parentPaddingTop","parseInt","parentPaddingBottom","bottom","setup","offsetBottom","scrollPane","isScheduled","scheduleOnLayout","requestAnimationFrame","nextMode","onLayout","mode","changeMode","viewPortHeight","scrollPaneDims","nodeHeight","nodeDims","concat","scrollPaneOffset","parentHeight","naturalTop","parentDims","relativeOffset2","Math","max","latestScrollY","nextBottom","scrollY","scrollTop","isBoxTooLow","relativeOffset","scrollPaneIsOffsetEl","_ref","parentNode","parentPaddings","_ref2","_ref3","newMode","prevMode","position","onScroll","scrollDelta","topOffset","bottomOffset","handleScroll","useStickyBox","arguments","length","undefined","setNode","forEach","fn","StickyBox","props","children","className","ref","src_default","default"],"sources":["C:/Users/Dell/Desktop/New -website RealState/my-app/node_modules/react-sticky-box/dist/index.js"],"sourcesContent":["// src/index.tsx\nimport { useEffect, useState } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar getScrollParent = (node) => {\n  let parent = node;\n  while (parent = parent.parentElement) {\n    const overflowYVal = getComputedStyle(parent, null).getPropertyValue(\"overflow-y\");\n    if (parent === document.body)\n      return window;\n    if (overflowYVal === \"auto\" || overflowYVal === \"scroll\" || overflowYVal === \"overlay\") {\n      return parent;\n    }\n  }\n  return window;\n};\nvar isOffsetElement = (el) => el.firstChild ? el.firstChild.offsetParent === el : true;\nvar offsetTill = (node, target) => {\n  let current = node;\n  let offset = 0;\n  if (!isOffsetElement(target)) {\n    offset += node.offsetTop - target.offsetTop;\n    target = node.offsetParent;\n    offset += -node.offsetTop;\n  }\n  do {\n    offset += current.offsetTop;\n    current = current.offsetParent;\n  } while (current && current !== target);\n  return offset;\n};\nvar getParentNode = (node) => {\n  let currentParent = node.parentElement;\n  while (currentParent) {\n    const style = getComputedStyle(currentParent, null);\n    if (style.getPropertyValue(\"display\") !== \"contents\")\n      break;\n    currentParent = currentParent.parentElement;\n  }\n  return currentParent || window;\n};\nvar stickyProp = null;\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n  if (CSS.supports(\"position\", \"sticky\"))\n    stickyProp = \"sticky\";\n  else if (CSS.supports(\"position\", \"-webkit-sticky\"))\n    stickyProp = \"-webkit-sticky\";\n}\nvar passiveArg = false;\ntry {\n  const opts = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get() {\n      passiveArg = { passive: true };\n    }\n  });\n  const emptyHandler = () => {\n  };\n  window.addEventListener(\"testPassive\", emptyHandler, opts);\n  window.removeEventListener(\"testPassive\", emptyHandler, opts);\n} catch (e) {\n}\nvar getDimensions = (opts) => {\n  const { el, onChange, unsubs, measure } = opts;\n  if (el === window) {\n    const getRect = () => ({ top: 0, left: 0, height: window.innerHeight, width: window.innerWidth });\n    const mResult = measure(getRect());\n    const handler = () => {\n      Object.assign(mResult, measure(getRect()));\n      onChange();\n    };\n    window.addEventListener(\"resize\", handler, passiveArg);\n    unsubs.push(() => window.removeEventListener(\"resize\", handler));\n    return mResult;\n  } else {\n    const mResult = measure(el.getBoundingClientRect());\n    const handler = () => {\n      Object.assign(mResult, measure(el.getBoundingClientRect()));\n      onChange();\n    };\n    const ro = new ResizeObserver(handler);\n    ro.observe(el);\n    unsubs.push(() => ro.disconnect());\n    return mResult;\n  }\n};\nvar getVerticalPadding = (node) => {\n  const computedParentStyle = getComputedStyle(node, null);\n  const parentPaddingTop = parseInt(computedParentStyle.getPropertyValue(\"padding-top\"), 10);\n  const parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue(\"padding-bottom\"), 10);\n  return { top: parentPaddingTop, bottom: parentPaddingBottom };\n};\nvar setup = (node, unsubs, opts) => {\n  const { bottom, offsetBottom, offsetTop } = opts;\n  const scrollPane = getScrollParent(node);\n  let isScheduled = false;\n  const scheduleOnLayout = () => {\n    if (!isScheduled) {\n      requestAnimationFrame(() => {\n        const nextMode = onLayout();\n        if (nextMode !== mode) {\n          changeMode(nextMode);\n        } else if (nextMode === 1 /* stickyBottom */ && !bottom) {\n          const { height: viewPortHeight } = scrollPaneDims;\n          const { height: nodeHeight } = nodeDims;\n          node.style.top = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        } else if (nextMode === 2 /* relative */) {\n          const { height: viewPortHeight, offsetTop: scrollPaneOffset } = scrollPaneDims;\n          const { height: parentHeight, naturalTop } = parentDims;\n          const { height: nodeHeight } = nodeDims;\n          const relativeOffset2 = Math.max(\n            0,\n            scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)\n          );\n          if (bottom) {\n            const nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset2);\n            node.style.bottom = `${nextBottom}px`;\n          } else {\n            node.style.top = `${relativeOffset2}px`;\n          }\n        }\n        isScheduled = false;\n      });\n    }\n    isScheduled = true;\n  };\n  let latestScrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;\n  const isBoxTooLow = (scrollY) => {\n    const { offsetTop: scrollPaneOffset, height: viewPortHeight } = scrollPaneDims;\n    const { naturalTop } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (scrollY + scrollPaneOffset + viewPortHeight >= naturalTop + nodeHeight + relativeOffset + offsetBottom) {\n      return true;\n    }\n    return false;\n  };\n  const onLayout = () => {\n    const { height: viewPortHeight } = scrollPaneDims;\n    const { height: nodeHeight } = nodeDims;\n    if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {\n      return 3 /* small */;\n    } else {\n      if (isBoxTooLow(latestScrollY)) {\n        return 1 /* stickyBottom */;\n      } else {\n        return 2 /* relative */;\n      }\n    }\n  };\n  const scrollPaneIsOffsetEl = scrollPane !== window && isOffsetElement(scrollPane);\n  const scrollPaneDims = getDimensions({\n    el: scrollPane,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height, top }) => ({\n      height,\n      offsetTop: scrollPaneIsOffsetEl ? top : 0\n    })\n  });\n  const parentNode = getParentNode(node);\n  const parentPaddings = parentNode === window ? { top: 0, bottom: 0 } : getVerticalPadding(parentNode);\n  const parentDims = getDimensions({\n    el: parentNode,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height }) => ({\n      height: height - parentPaddings.top - parentPaddings.bottom,\n      naturalTop: parentNode === window ? 0 : offsetTill(parentNode, scrollPane) + parentPaddings.top + scrollPaneDims.offsetTop\n    })\n  });\n  const nodeDims = getDimensions({\n    el: node,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height }) => ({ height })\n  });\n  let relativeOffset = 0;\n  let mode = onLayout();\n  const changeMode = (newMode) => {\n    const prevMode = mode;\n    mode = newMode;\n    if (prevMode === 2 /* relative */)\n      relativeOffset = -1;\n    if (newMode === 3 /* small */) {\n      node.style.position = stickyProp;\n      if (bottom) {\n        node.style.bottom = `${offsetBottom}px`;\n      } else {\n        node.style.top = `${offsetTop}px`;\n      }\n      return;\n    }\n    const { height: viewPortHeight, offsetTop: scrollPaneOffset } = scrollPaneDims;\n    const { height: parentHeight, naturalTop } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (newMode === 2 /* relative */) {\n      node.style.position = \"relative\";\n      relativeOffset = prevMode === 0 /* stickyTop */ ? Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop) : Math.max(\n        0,\n        scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)\n      );\n      if (bottom) {\n        const nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset);\n        node.style.bottom = `${nextBottom}px`;\n      } else {\n        node.style.top = `${relativeOffset}px`;\n      }\n    } else {\n      node.style.position = stickyProp;\n      if (newMode === 1 /* stickyBottom */) {\n        if (bottom) {\n          node.style.bottom = `${offsetBottom}px`;\n        } else {\n          node.style.top = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        }\n      } else {\n        if (bottom) {\n          node.style.bottom = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        } else {\n          node.style.top = `${offsetTop}px`;\n        }\n      }\n    }\n  };\n  changeMode(mode);\n  const onScroll = (scrollY) => {\n    if (scrollY === latestScrollY)\n      return;\n    const scrollDelta = scrollY - latestScrollY;\n    latestScrollY = scrollY;\n    if (mode === 3 /* small */)\n      return;\n    const { offsetTop: scrollPaneOffset, height: viewPortHeight } = scrollPaneDims;\n    const { naturalTop, height: parentHeight } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (scrollDelta > 0) {\n      if (mode === 0 /* stickyTop */) {\n        if (scrollY + scrollPaneOffset + offsetTop > naturalTop) {\n          const topOffset = Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop);\n          if (scrollY + scrollPaneOffset + viewPortHeight <= naturalTop + nodeHeight + topOffset + offsetBottom) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(1 /* stickyBottom */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (isBoxTooLow(scrollY))\n          changeMode(1 /* stickyBottom */);\n      }\n    } else {\n      if (mode === 1 /* stickyBottom */) {\n        if (scrollPaneOffset + scrollY + viewPortHeight < naturalTop + parentHeight + offsetBottom) {\n          const bottomOffset = Math.max(\n            0,\n            scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)\n          );\n          if (scrollPaneOffset + scrollY + offsetTop >= naturalTop + bottomOffset) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(0 /* stickyTop */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (scrollPaneOffset + scrollY + offsetTop < naturalTop + relativeOffset) {\n          changeMode(0 /* stickyTop */);\n        }\n      }\n    }\n  };\n  const handleScroll = scrollPane === window ? () => onScroll(window.scrollY) : () => onScroll(scrollPane.scrollTop);\n  scrollPane.addEventListener(\"scroll\", handleScroll, passiveArg);\n  scrollPane.addEventListener(\"mousewheel\", handleScroll, passiveArg);\n  unsubs.push(\n    () => scrollPane.removeEventListener(\"scroll\", handleScroll),\n    () => scrollPane.removeEventListener(\"mousewheel\", handleScroll)\n  );\n};\nvar useStickyBox = ({\n  offsetTop = 0,\n  offsetBottom = 0,\n  bottom = false\n} = {}) => {\n  const [node, setNode] = useState(null);\n  useEffect(() => {\n    if (!node || !stickyProp)\n      return;\n    const unsubs = [];\n    setup(node, unsubs, { offsetBottom, offsetTop, bottom });\n    return () => {\n      unsubs.forEach((fn) => fn());\n    };\n  }, [node, offsetBottom, offsetTop, bottom]);\n  return setNode;\n};\nvar StickyBox = (props) => {\n  const { offsetTop, offsetBottom, bottom, children, className, style } = props;\n  const ref = useStickyBox({ offsetTop, offsetBottom, bottom });\n  return /* @__PURE__ */ jsx(\"div\", { className, style, ref, children });\n};\nvar src_default = StickyBox;\nexport {\n  src_default as default,\n  useStickyBox\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}